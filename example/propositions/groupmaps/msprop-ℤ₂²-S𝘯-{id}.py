def fun(args):
   return args[0] == 'ℤ₂²' and isSymmetric(args[1]) and args[2] == '{id}'
""" """
def fun(args):
   n=GSubscriptDigits.index(args[1][1])
   count = 0
   for b in range((n//4) + 1):
      for i in range((n//2) + 1):
         for j in range((n//2) + 1):
            for k in range((n//2) + 1):
               if 2*(2*b+i+j+k) < n+1 and (b>0 or sum([1 if x>0 else 0 for x in [i,j,k]]) > 1):
                  count += factorial(n) / (factorial(b) * 4**b *  2**(i+j+k) *factorial(i) * factorial(j) * factorial(k) * factorial(n-2*(2*b+i+j+k)))
   return int(count)

#n! / (b! 4^b 2^(i+j+k) i! j! k! (n-2(2b+i+j+k))!)


"""

ℤ₂² S𝘯 {id}

in general:
permutation
123456
assume wlog that 

well basically its:
   choose a chunk 2k of k blocks.
   then choose two nonidentical subsets of the 2k blocks.
   done!
   ... except, we want to specify that all the blocks are taken. or, not choose the blocks first, or osmething...

ah... tripartite, and then...
no qudripartite, and then, in both, neither , 1, other.
require that all but neither is occupatied.

...
take an image I. let it be generated by b and c. b and c are distinct sets of transpositions, all of which are either disjoint or identical 
wlog, we have that b and c share a transposition: if not, bc shares with both.
wlog, b has a transposition that c doesn't have (they must differ)
so, we can take all permutations. the first will be shared, and the second will be in b but not c. the remainder can be distributed in any way, satisfying disjoint / identical.
wait this seems bad, how to track which pairs give equivalent things?

ok right, instead we say: there are 3 disjoint sets, A B C, of transpositions (all disjoint).
one element of our D₂ is the transpositions in A+B, another A+C, another B+C.
this gives a valid copy of D₂ iff at most one of A B C is empty.
so we have eg 
A:(12)(34)
B:(56)
C:(78)
unassigned: 9,10,11
for S₁₁
we take one generator to A+B and the other to B+C (or whatever), so that the order of ABC is meaningful (permuting them gives a different embedding). for a given configuation of ABC, that is, choice of their sizes, we permute [n] and then mod out by permuting each pair within a transposition, permuting tranpositions within each of ABC, and permuting the remaining elements of [n]
so it's...
sum 0 ≤ i ≤ n//2
sum 0 ≤ j ≤ n//2
sum 0 ≤ k ≤ n//2
s.t. 2(i+j+k) ≤ n
s.t. sum([1 if x>0 else 0 for x in [i,j,k]]) > 1
n! / (2^(i+j+k) i! j! k! (n-2(i+j+k))!)

result:
18    
90    
630   
3150  
19530 
106218
[18, 90, 630, 3150, 19530, 106218]
not in oeis...  would submit but idk if i made a mistake... want to know if there's a closed form / better analysis!

....
WAIT this is wrong!
can have 
{(12)(34), (13)(24), (14)(23), e}
i think that's it, you have to get back around after 2. 
so....
we have to also choose a number of blocks of 4.  we fix the pattern [(12)(34), (13)(24), (14)(23)]. the blocks of four themselves can be permuted; the transpositions in a block can be permuted, like: 
[(12)(34), (13)(24), (14)(23)]
-> [(34)(12), (31)(42), (32)(41)]
and we can at the same time permute both pairs of elements of a transposition in a 4 block, like: 
[(12)(34), (13)(24), (14)(23)]
-> [(21)(43), (24)(13), (23)(14)]
and both, but not just swapping a single transposition, as that changes the others:
[(12)(34), (13)(24), (14)(23)]
X-> [(12)(43), (14)(23), (13)(24)]

having at least 1 4block satisfies nontriviality

so:
sum 0 ≤ b ≤ n//4
sum 0 ≤ i ≤ n//2
sum 0 ≤ j ≤ n//2
sum 0 ≤ k ≤ n//2
s.t. 2(2b+i+j+k) ≤ n
s.t. b>0 or sum([1 if x>0 else 0 for x in [i,j,k]]) > 1
n! / (b! 4^b 2^(i+j+k) i! j! k! (n-2(2b+i+j+k))!)


0     , 24    , 120   , 990   , 5250  , 40110 , 243054, 
